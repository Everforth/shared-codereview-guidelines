## Service層（ビジネスロジック、データ処理 等）

### 必須チェック項目：

#### ビジネスロジック

- **ビジネスロジックの正確性**: データの加工、計算、判定処理が仕様通りに実装されているか
- **責務分離**: Serviceがビジネスロジックのみに集中し、HTTP関連の処理を含んでいないか
- **トランザクション境界**: データベーストランザクションが適切なスコープで設定されているか
- **データ変換処理**: EntityからDTOへの変換、外部APIレスポンスの変換が適切か
- **エラーハンドリング**: エラーを適切に処理し例外をスローしているか（HTTPステータスはControllerで決定）
- **暗黙的な前提条件の排除**: メソッドが外部での事前チェックを前提としていないか、単体で正しく動作するか
- **DTOにロジックを含めない**: データ変換やフィルタリングはServiceの責務であり、DTOのコンストラクタで行わない

#### コード品質

- **重複コードの排除**: 類似ロジックの有無を確認し、共通関数やServiceを再利用しているか
- **Service間の依存関係**: 他のServiceへの依存が適切で、循環参照を避けているか
- **不要なモジュールのインポート削除**: 使用していないモジュールやライブラリがインポートされていないか
- **非同期処理**: Promiseを返す処理に`await`が適切に付与されているか
- **nullチェックの適切な配置**: null checkを追加する前に、呼び出し元でnullを排除できないか確認する
- **命名による責務の識別**: 同ファイル内で命名からそれぞれの責務の違いが判別できるか
- **オプションによる挙動制御**: 「ほぼ同じだが、追加の挙動がある」処理は、メソッドを分けるのではなくオプションで追加の挙動を制御する
- **デフォルト選択の明確化**: 類似名のメソッド・クラスがある場合、どちらをデフォルトで使うべきか命名から明確か
- **ユースケース基準のメソッド分割**: メソッドを分けるかどうかは「実装の違い」ではなく「呼び出し側のユースケースの違い」で判断する

#### 型安全性

- **any型の禁止**: 型を明示的に定義し、any型の使用を避ける
- **不適切なasキャストの回避**: 暗黙的な前提に基づいて型推論エラーを握りつぶさず、正規の方法で値を取得する
- **設定値の明示化**: `undefined`/`null`に特別な意味を持たせず、明示的な値（Enum、定数等）で意図を表現し、設定漏れを型で検出可能にする

#### 設計

- **カラム名とデータの整合性**: カラム名が示す意味と実際に保存されるデータを一致させる
- **関心の分離**: 外部システムとの契約（メタデータキー、イベント型など）とビジネス設定（どのエンティティをどう処理するか）は別ファイルに分離する

### パフォーマンス考慮点：

- バッチ処理での一括操作
- 適切なキャッシュ戦略（TTL設定）
- 不要なDB呼び出しの削減
- upsertパターンの適切な使用: race condition対策コードは高ボリューム箇所のみに限定

### TypeORM使用方針：

- QueryBuilderよりRepository APIを優先: QueryBuilderは型推論が効かないため、複雑なクエリが必要な場合を除きRepository APIを使用する
- `FindManyOptions<Entity>`型の明示: `repository.find()`等に渡すオプションは`FindManyOptions<Entity>`型を明示する
- `repository.save()`/`entityManager.save()`は「🟨 確認」として指摘。N+1クエリを発行するため、高ボリューム時はQueryBuilder検討を促す
- ページネーションライブラリの活用: パフォーマンス最適化が必須の箇所を除き、`nestjs-typeorm-paginate`等の標準ライブラリで保守性を確保する

### 設計規則：

- 特殊な実装には必ずコメントで理由を明記
- モジュール間で名前の衝突を避ける
- 型変換ロジックの配置: 型の変換を担うロジックは、その型を定義したファイル内で責任を持つ（transform関数として型定義ファイルにexport）

### この層で扱わないこと：

**DB層の責務:**

- Entity定義、データベーススキーマ
- TypeORMクエリビルダーの詳細（Serviceでは「どのデータを取得するか」のみ）

**Controller層の責務:**

- DTO定義・バリデーション、HTTPリクエスト/レスポンス処理
- HTTPステータスコード決定、認証・認可ガード設定、ルーティング
