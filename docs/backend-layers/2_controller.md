## Controller層（エンドポイント、リクエスト/レスポンス処理、DTO 等）

### 必須チェック項目：

- **APIエンドポイント設計**:
  - 既存のエンドポイントパターンに合わせた一貫性のあるRESTful設計
  - リソース指向のURL構造（動詞ではなく名詞を使用）
  - 適切なHTTPメソッドの使用（GET/POST/PUT/PATCH/DELETE）
  - ファイルとDTOを同一エンドポイントで受け取らず、ファイル受信用とメタデータ更新用のAPIを分離する
- **Pipeの活用**: ValidationPipe、ParseIntPipeなどの適切なPipeを使用しているか
- **DTOバリデーション設計**:
  - class-validatorのデコレータを使用した入力検証の実装
  - 必須/任意フィールドの明確な定義
  - 適切な型制約とカスタムバリデーションルール
  - 文字列フィールドには文字数制限を設定する
- **DTOの責務**:
  - バックエンド側で埋める項目はDTOに含めない
  - 外部システムの知識（外部APIのタグ形式等）をDTOに漏らさず、Service層で変換する
- **責務分離**: Controller/Serviceの役割が適切に分離されているか
- **エラー処理**: 適切なHTTPステータスコードを返し、意味のあるエラーメッセージを提供しているか
- **セキュリティ**: 認証・認可ガードが正しく設定されているか
- **型設計**: DTOでPartialTypeを活用し、既存型定義を再利用しているか

### パフォーマンス考慮点：

- 適切なキャッシュ戦略（TTL設定）

### 設計・命名規則：

- RESTfulなAPI設計を重要視しつつ既存のコードベースのエンドポイント命名規則に従う
- モジュール間で名前の衝突を避ける
- URLパラメータ名とEntityのプロパティ名を一致させる（例: Entityが`uuid`なら`:uuid`を使用）
- DTOのクラス名とファイル名にrequest/responseの役割を明示する

### Swaggerドキュメンテーション：

- **基本方針**: NestJSが自動生成するSwaggerドキュメントがあるため、複雑でない限りデコレータは避ける
- **デコレータ適用の判断基準**:
  - 変数名から用途が自明な場合: デコレータ不要
  - デフォルトで設定される値の場合: デコレータ不要
  - 変数名から解釈しづらい場合のみ: @ApiProperty()でdescriptionを追加
  - エンドポイントのドキュメント: シンプルで理解しやすい場合は記述しない
- **推奨事項**:
  - DTOのプロパティ名は意味が明確になるよう命名し、不要なドキュメントを減らす
  - 複雑なビジネスロジックや特殊な制約がある場合のみ詳細な説明を追加

### レビュー対象外：

以下はController層ではなく、他の層でレビューすること：

- **Entity定義**（@Entity()デコレータ付きクラス）→ DB層で扱う
- **データベーススキーマ、マイグレーション** → DB層で扱う
- **ビジネスロジックの実装**（複雑な計算、データ変換処理）→ Service層で扱う
- **外部APIとの通信処理** → Service層で扱う
