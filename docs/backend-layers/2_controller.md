## Controller層（エンドポイント、リクエスト/レスポンス処理、DTO 等）

### 必須チェック項目：

- **APIエンドポイント設計**:
  - 既存のエンドポイントパターンに合わせた一貫性のあるRESTful設計
  - リソース指向のURL構造（動詞ではなく名詞を使用）
  - 適切なHTTPメソッドの使用（GET/POST/PUT/PATCH/DELETE）
  - ファイルとDTOを同一エンドポイントで受け取らず、ファイル受信用とメタデータ更新用のAPIを分離する
  - 常に固定値で良いパラメータは、APIパラメータとして公開せず内部で固定する
- **Pipeの活用**:
  - ValidationPipe、ParseIntPipeなどの適切なPipeを使用しているか
  - 文字列型で受けると緩すぎる場合は、専用のPipe（ParseIntPipe、ParseMonthPipe等）を使用して型安全性を確保する
  - 日付や数値のパースなど汎用的な処理は、既存のカスタムPipeを活用する
- **DTOバリデーション設計**:
  - class-validatorのデコレータを使用した入力検証の実装
  - 必須/任意フィールドの明確な定義
  - 適切な型制約とカスタムバリデーションルール
  - 文字列フィールドには文字数制限を設定する
- **APIリクエストのバリデーション厳格化**:
  - 無駄にoptionalやnullを付けない
  - any型禁止
  - 自由なテキスト入力でない場合はstring型禁止（カスタムPipeを作成して対応）
- **DTOの責務**:
  - バックエンド側で埋める項目はDTOに含めない
  - 外部システムの知識（外部APIのタグ形式等）をDTOに漏らさず、Service層で変換する
- **責務分離**: Controller/Serviceの役割が適切に分離されているか
- **入力値の正規化はController層の責務**: 0以下をundefinedに変換する等の入力値正規化はvalidationの一部であり、Controller層で行う
- **エラー処理**: 適切なHTTPステータスコードを返し、意味のあるエラーメッセージを提供しているか
- **セキュリティ**: 認証・認可ガードが正しく設定されているか（グローバルガード設定を確認した上で判断する）
- **型設計**: DTOでPartialTypeを活用し、既存型定義を再利用しているか

### パフォーマンス考慮点：

- 適切なキャッシュ戦略（TTL設定）

### 設計・命名規則：

- RESTfulなAPI設計を重要視しつつ既存のコードベースのエンドポイント命名規則に従う
- モジュール間で名前の衝突を避ける
- URLパラメータ名とEntityのプロパティ名を一致させる（例: Entityが`uuid`なら`:uuid`を使用）
- DTOのクラス名とファイル名にrequest/responseの役割を明示する

### Swaggerドキュメンテーション：

- **基本方針**: NestJSが自動生成するSwaggerドキュメントがあるため、複雑でない限りデコレータは避ける
- **デコレータ適用の判断基準**:
  - 変数名から用途が自明な場合: デコレータ不要
  - デフォルトで設定される値の場合: デコレータ不要
  - 変数名から解釈しづらい場合のみ: @ApiProperty()でdescriptionを追加
  - エンドポイントのドキュメント: シンプルで理解しやすい場合は記述しない
- **推奨事項**:
  - DTOのプロパティ名は意味が明確になるよう命名し、不要なドキュメントを減らす
  - 複雑なビジネスロジックや特殊な制約がある場合のみ詳細な説明を追加

### この層で扱わないこと：

- Entity定義（DB層の責務）
- データベーススキーマ、マイグレーション（DB層の責務）
- ビジネスロジックの実装（Service層の責務）
- 外部APIとの通信処理（Service層の責務）
- CRUDの網羅性（その時点で必要な最低限の実装があれば良い）
